import{_ as e,o as a,c as t,V as o}from"./chunks/framework.7ae304b1.js";const i="/assets/dna.d57732b7.jpg",_=JSON.parse('{"title":"DNA","description":"","frontmatter":{},"headers":[],"relativePath":"ai/dna.md","filePath":"ai/dna.md"}'),n={name:"ai/dna.md"},s=o('<h1 id="dna" tabindex="-1">DNA <a class="header-anchor" href="#dna" aria-label="Permalink to &quot;DNA&quot;">​</a></h1><h2 id="code-data-as-dna" tabindex="-1">Code + Data as DNA <a class="header-anchor" href="#code-data-as-dna" aria-label="Permalink to &quot;Code + Data as DNA&quot;">​</a></h2><p><img src="'+i+'" alt="dna.jpg"></p><p>Because both the algorithm and the data can be stored an accessed in a uniform way, we can treat each attribute as a <a href="https://en.wikipedia.org/wiki/DNA_sequencing" target="_blank" rel="noreferrer">base</a> that makes up a greater DNA seqeunce. The DNA sequence determines the behavior.</p><p>By expressing everything in a standardized format (JSON), it becomes easy to synthesize various base features to accomplish interesting goals, while maintaining a high level cohesive structure.</p><ol><li><strong>Designed to be remixed:</strong> Everything in Pinokio is JSON, which means you can store code as data, and data as code. Basically, Pinokio is not &quot;an engine that lets you use AI&quot;, but an AI itself, complete with its own native memory. <ul><li><strong>Code (JSON-RPC):</strong> Every Pinokoio API method follows the same protocol (they must have the same top level function signature), and this standardized input/output interface makes it easy to switch out one module to another.</li><li><strong>Data:</strong> JSON</li></ul></li><li><strong>Self organization:</strong> The Pinokio system automatically merges all the JSON modules in realtime. You can create emergent behaviors simply by dropping certain JSON structures in the App/API repository.</li></ol>',6),r=[s];function d(l,c,h,u,m,p){return a(),t("div",null,r)}const f=e(n,[["render",d]]);export{_ as __pageData,f as default};
