import{_ as e,o as t,c as n,V as a}from"./chunks/framework.7ae304b1.js";const i="/assets/neuron.20788ce7.png",_=JSON.parse('{"title":"Neuron","description":"","frontmatter":{},"headers":[],"relativePath":"ai/neuron.md","filePath":"ai/neuron.md"}'),o={name:"ai/neuron.md"},r=a('<h1 id="neuron" tabindex="-1">Neuron <a class="header-anchor" href="#neuron" aria-label="Permalink to &quot;Neuron&quot;">​</a></h1><h2 id="deterministic-intelligence" tabindex="-1">Deterministic intelligence <a class="header-anchor" href="#deterministic-intelligence" aria-label="Permalink to &quot;Deterministic intelligence&quot;">​</a></h2><p>Most typically, a Pinokio script will have a single threaded deterministic routine (example: &quot;generate some text, then generate an image based on this text, and finally publish it somewhere&quot;)</p><p>But because each step is easily replaceable (thanks to the standardized JSON interface), we can--on the fly--change what APIs are called next, as well as how they are called, which leads us to...</p><h2 id="non-deterministic-intelligence" tabindex="-1">Non-deterministic intelligence <a class="header-anchor" href="#non-deterministic-intelligence" aria-label="Permalink to &quot;Non-deterministic intelligence&quot;">​</a></h2><p><img src="'+i+'" alt="neuron.png"></p><p>Thanks to the standardized RPC interface, we can even treat each API as a neuron in a larger neural network.</p><p>By now we know that a Pinokio script can mutate itself as well as mutate its own memory during execution.</p><p>And this means we no longer need a single timeline. We can create have multiple options and assign a probability to each of these options.</p><p>For example, depending on the condition, you may want to generate some text using a language model, and then either feed it to a text-to-image engine, or a text-to-video, or even a text-to-audio engine.</p><p>We could even create an API that determines the probability of which actions to trigger based on the current <code>self</code> state as well as the <code>local</code> and <code>global</code> memory variables, and insert it in the logic.</p><p>There are a couple of ways to do this:</p><ol><li>Use the template expression and the auto-construction feature to generate the next step in JSON</li><li>Write the script in JavaScript (to dynamically return a specific JSON depending on some complex logic, or based on probability)</li></ol>',13),s=[r];function l(c,d,h,p,u,m){return t(),n("div",null,s)}const f=e(o,[["render",l]]);export{_ as __pageData,f as default};
